// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}


datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

model User {
  id               String    @id @default(auto()) @map("_id") @db.ObjectId
  email            String    @unique
  password         String
  firstName        String
  lastName         String
  phone            String
  address          String?
  city             String?
  state            String?
  country          String    @default("VN")
  postalCode       String?
  dateOfBirth      DateTime?
  profilePicture   String?
  linkedInUrl      String?
  githubUrl        String?
  portfolioUrl     String?
  personalWebsite  String?
  profileSummary   String?
  role             String    @default("client")
  subscriptionPlan String    @default("free")
  subscriptionExpiry DateTime?
  isEmailVerified  Boolean   @default(false)
  isPhoneVerified  Boolean   @default(false)
  lastLoginAt      DateTime?
  timezone         String    @default("Asia/Ho_Chi_Minh")
  language         String    @default("vi")
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  isActive         Boolean   @default(true)
  deletedAt        DateTime?

  // Auth Relations
  userRoles              UserRole[]
  userPermissions        UserPermission[]
  refreshTokens          RefreshToken[]
  devices                Device[]
  loginSessions          LoginSession[]
  verificationCodes      VerificationCode[]

  rolesCreated           Role[]            @relation("RoleCreatedBy")
  rolePermissionsGranted RolePermission[]  @relation("RolePermissionGrantedBy")
  userRolesAssigned      UserRole[]        @relation("UserRoleAssignedBy")
  userPermissionsGranted UserPermission[]  @relation("UserPermissionGrantedBy")
  refreshTokensRevoked   RefreshToken[]    @relation("RefreshTokenRevokedBy")

  // Kahoot & related modules
  kahoots        Kahoot[]          @relation("UserKahoots")
  hostedLobbies  LobbySession[]    @relation("UserHostedLobbies")
  lobbyPlayers   LobbyPlayer[]     @relation("UserLobbyPlayers")
  challenges     Challenge[]       @relation("UserChallenges")
  challengeAttempts ChallengeAttempt[] @relation("UserChallengeAttempts")
  gameReports    GameReport[]      @relation("UserGameReports")
  reportPlayers  ReportPlayer[]    @relation("UserReportPlayers")
  favorites      Favorite[]        @relation("UserFavorites")
  comments       Comment[]         @relation("UserComments")
  auditLogs      AuditLog[]        @relation("UserAuditLogs")
  files          File[]            @relation("UserFiles")
  @@map("users")
}

model Role {
    id               String    @id @default(auto()) @map("_id") @db.ObjectId
    name             String    @unique // admin, employer, candidate, moderator
    slug             String    @unique
    displayName      String
    description      String?
    level            Int       @default(0) // Role hierarchy level (0=lowest, 100=highest)
    isSystemRole     Boolean   @default(false) // Cannot be deleted/modified
    isActive         Boolean   @default(true)
    permissions      Json?     // Quick access permissions cache
    createdBy        String?   @db.ObjectId
    createdAt        DateTime  @default(now())
    updatedAt        DateTime  @updatedAt

    // Relations
    creator          User?     @relation("RoleCreatedBy", fields: [createdBy], references: [id])
    rolePermissions  RolePermission[]
    userRoles        UserRole[]

    @@map("roles")
  }

model Permission {
  id                   String    @id @default(auto()) @map("_id") @db.ObjectId
  name                 String    @unique // users:read, cvs:create, jobs:delete
  slug                 String    @unique
  displayName          String
  description          String?
  resource             String    // users, cvs, jobs, companies, etc.
  action               String    // create, read, update, delete, manage
  conditions           Json?     // Additional conditions for permission
  category             String?   // user-management, cv-management, job-management
  isSystemPermission   Boolean   @default(false)
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt

  // Relations
  rolePermissions      RolePermission[]
  userPermissions      UserPermission[]

  @@map("permissions")
}

model RolePermission {
  id            String    @id @default(auto()) @map("_id") @db.ObjectId
  roleId        String    @db.ObjectId
  permissionId  String    @db.ObjectId
  conditions    Json?     // Role-specific conditions for this permission
  isGranted     Boolean   @default(true) // true=granted, false=denied
  grantedBy     String?   @db.ObjectId
  grantedAt     DateTime  @default(now())

  // Relations
  role          Role      @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission    Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  grantor       User?     @relation("RolePermissionGrantedBy", fields: [grantedBy], references: [id])

  @@unique([roleId, permissionId])
  @@map("role_permissions")
}

model UserRole {
  id          String    @id @default(auto()) @map("_id") @db.ObjectId
  userId      String    @db.ObjectId
  roleId      String    @db.ObjectId
  assignedBy  String?   @db.ObjectId
  assignedAt  DateTime  @default(now())
  expiresAt   DateTime? // Role expiration date, null = permanent
  isActive    Boolean   @default(true)
  metadata    Json?     // Additional role assignment metadata

  // Relations
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  role        Role      @relation(fields: [roleId], references: [id], onDelete: Cascade)
  assignor    User?     @relation("UserRoleAssignedBy", fields: [assignedBy], references: [id])

  @@unique([userId, roleId])
  @@map("user_roles")
}

model UserPermission {
  id            String    @id @default(auto()) @map("_id") @db.ObjectId
  userId        String    @db.ObjectId
  permissionId  String    @db.ObjectId
  isGranted     Boolean   @default(true) // true=granted, false=denied (override)
  conditions    Json?     // User-specific conditions
  grantedBy     String?   @db.ObjectId
  grantedAt     DateTime  @default(now())
  expiresAt     DateTime? // Permission expiration date
  reason        String?   // Reason for granting/denying this permission

  // Relations
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  permission    Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  grantor       User?     @relation("UserPermissionGrantedBy", fields: [grantedBy], references: [id])

  @@unique([userId, permissionId])
  @@map("user_permissions")
}

model RefreshToken {
  id             String    @id @default(auto()) @map("_id") @db.ObjectId
  userId         String    @db.ObjectId
  token          String    @unique
  deviceId       String?   @db.ObjectId
  expiresAt      DateTime
  isRevoked      Boolean   @default(false)
  revokedAt      DateTime?
  revokedBy      String?   @db.ObjectId // Admin who revoked the token
  revokedReason  String?   // Reason for token revocation
  lastUsedAt     DateTime?
  usageCount     Int       @default(0)
  ipAddress      String?
  userAgent      String?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  // Relations
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  device         Device?   @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  revoker        User?     @relation("RefreshTokenRevokedBy", fields: [revokedBy], references: [id])
  loginSessions  LoginSession[]

  @@map("refresh_tokens")
}

model Device {
  id                String    @id @default(auto()) @map("_id") @db.ObjectId
  userId            String    @db.ObjectId
  deviceId          String    @unique // Unique device identifier
  deviceName        String?   // User-defined device name
  deviceType        String?   // mobile, desktop, tablet, tv, watch
  platform          String?   // iOS, Android, Windows, macOS, Linux, Web
  browser           String?   // Chrome, Firefox, Safari, Edge, etc.
  browserVersion    String?
  os                String?   // Operating system
  osVersion         String?
  appVersion        String?   // App version if mobile
  pushToken         String?   // Push notification token
  fingerprint       String?   // Device fingerprint
  ipAddress         String?
  location          Json?     // Last known location {country, city, lat, lng}
  isTrusted         Boolean   @default(false) // User-marked trusted device
  isActive          Boolean   @default(true)
  isBlocked         Boolean   @default(false)
  lastSeenAt        DateTime?
  firstSeenAt       DateTime  @default(now())
  loginCount        Int       @default(0)
  sessionCount      Int       @default(0) // Number of active sessions
  maxSessions       Int       @default(5) // Max concurrent sessions
  twoFactorEnabled  Boolean   @default(false)
  biometricEnabled  Boolean   @default(false)
  metadata          Json?     // Additional device metadata
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  refreshTokens     RefreshToken[]
  loginSessions     LoginSession[]
  verificationCodes VerificationCode[]
  @@unique([userId, deviceId])
  @@map("devices")
}

model LoginSession {
  id               String    @id @default(auto()) @map("_id") @db.ObjectId
  userId           String    @db.ObjectId
  deviceId         String?   @db.ObjectId
  sessionId        String    @unique
  refreshTokenId   String?   @db.ObjectId
  ipAddress        String?
  userAgent        String?
  location         Json?     // Login location
  loginMethod      String?   // password, google, facebook, apple, etc.
  twoFactorUsed    Boolean   @default(false)
  loginAt          DateTime  @default(now())
  lastActivityAt   DateTime?
  logoutAt         DateTime?
  isActive         Boolean   @default(true)
  duration         Int?      // Session duration in seconds
  metadata         Json?

  // Relations
  user             User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  device           Device?   @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  refreshToken     RefreshToken? @relation(fields: [refreshTokenId], references: [id])

  @@map("login_sessions")
}

model VerificationCode {
  id           String    @id @default(auto()) @map("_id") @db.ObjectId
  userId       String?   @db.ObjectId
  email        String?
  phone        String?
  code         String
  hashedCode   String    // Hashed version of code
  type         String    // email_verification, phone_verification, password_reset, two_factor, login_code
  purpose      String?   // Specific purpose of verification
  attempts     Int       @default(0)
  maxAttempts  Int       @default(3)
  isUsed       Boolean   @default(false)
  usedAt       DateTime?
  expiresAt    DateTime
  ipAddress    String?
  userAgent    String?
  deviceId     String?   @db.ObjectId
  metadata     Json?     // Additional verification metadata
  createdAt    DateTime  @default(now())

  // Relations
  user         User?     @relation(fields: [userId], references: [id], onDelete: Cascade)
  device       Device?   @relation(fields: [deviceId], references: [id])

   @@unique([type , code], name: "type_code", map: "type_code")
}

////////////////////////////////////////////////////////////
// KAHOOT BANK (Bộ câu hỏi theo phong cách Kahoot!)
////////////////////////////////////////////////////////////

enum KahootVisibility { 
  public
  unlisted
  private
}

enum AnswerShape { 
  triangle
  diamond
  circle
  square
}

model Kahoot {
  id            String   @id @default(auto()) @map("_id") @db.ObjectId
  ownerId       String   @db.ObjectId
  title         String
  description   String?
  visibility    KahootVisibility @default(public)
  coverImage    String?
  theme         String?
  musicTheme    String?
  isTeamModeOk  Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  publishedAt   DateTime?

  // Relations
  owner         User     @relation("UserKahoots", fields: [ownerId], references: [id], onDelete: Cascade)
  questions     KahootQuestion[]
  kahootTags    KahootTag[]
  favorites     Favorite[]
  comments      Comment[]
  lobbies       LobbySession[]
  challenges    Challenge[]
  reports       GameReport[]

  @@index([ownerId])
  @@index([visibility])
  @@map("kahoots")
}

model KahootQuestion {
  id              String   @id @default(auto()) @map("_id") @db.ObjectId
  kahootId        String   @db.ObjectId
  text            String?
  imageUrl        String?
  videoUrl        String?
  orderIndex      Int
  timeLimit       Int
  pointsMultiplier Float
  isMultipleSelect Boolean @default(false)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  deletedAt       DateTime?

  // Relations
  kahoot          Kahoot   @relation(fields: [kahootId], references: [id], onDelete: Cascade)
  answers         KahootAnswer[]
  responses       LobbyPlayerResponse[]
  challengeResponses ChallengeResponse[]

  @@index([kahootId, orderIndex])
  @@map("kahoot_questions")
}

model KahootAnswer {
  id          String      @id @default(auto()) @map("_id") @db.ObjectId
  questionId  String      @db.ObjectId
  text        String?
  isCorrect   Boolean     @default(false)
  shape       AnswerShape
  colorHex    String?
  orderIndex  Int

  // Relations
  question    KahootQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)
  responses   LobbyPlayerResponse[]
  challengeResponses ChallengeResponse[]

  @@index([questionId])
  @@map("kahoot_answers")
}

model Tag {
  id    String @id @default(auto()) @map("_id") @db.ObjectId
  name  String @unique
  kind  String?

  kahootTags KahootTag[]

  @@map("tags")
}

model KahootTag {
  id       String @id @default(auto()) @map("_id") @db.ObjectId
  kahootId String @db.ObjectId
  tagId    String @db.ObjectId

  // Relations
  kahoot   Kahoot @relation(fields: [kahootId], references: [id], onDelete: Cascade)
  tag      Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([kahootId, tagId])
  @@map("kahoot_tags")
}

////////////////////////////////////////////////////////////
// LIVE LOBBY
////////////////////////////////////////////////////////////

enum LobbyMode { 
  classic
  team
}

enum LobbyStatus { 
  waiting
  running
  ended
}

model LobbySession {
  id                  String   @id @default(auto()) @map("_id") @db.ObjectId
  kahootId            String   @db.ObjectId
  hostId              String   @db.ObjectId
  pinCode             String   @unique
  mode                LobbyMode @default(classic)
  status              LobbyStatus @default(waiting)
  answerOrderRandom   Boolean  @default(true)
  questionOrderRandom Boolean  @default(false)
  streaksEnabled      Boolean  @default(true)
  nicknameGenerator   Boolean  @default(true)
  startedAt           DateTime?
  endedAt             DateTime?
  settingsJson        String?
  createdAt           DateTime @default(now())

  // Relations
  kahoot              Kahoot   @relation(fields: [kahootId], references: [id], onDelete: Cascade)
  host                User     @relation("UserHostedLobbies", fields: [hostId], references: [id], onDelete: Cascade)
  teams               LobbyTeam[]
  players             LobbyPlayer[]
  responses           LobbyPlayerResponse[]

  @@map("lobby_sessions")
}

model LobbyTeam {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  sessionId  String   @db.ObjectId
  name       String
  createdAt  DateTime @default(now())

  // Relations
  session    LobbySession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  players    LobbyPlayer[]

  @@index([sessionId])
  @@map("lobby_teams")
}

model LobbyPlayer {
  id            String   @id @default(auto()) @map("_id") @db.ObjectId
  sessionId     String   @db.ObjectId
  teamId        String?  @db.ObjectId
  clientKey     String?          // giữ optional để client ẩn danh vẫn OK
  userId        String?  @db.ObjectId
  nickname      String
  isKicked      Boolean  @default(false)
  joinedAt      DateTime @default(now())
  leftAt        DateTime?
  finalScore    Float?
  streakCurrent Int      @default(0)
  streakMax     Int      @default(0)

  // Relations
  session   LobbySession       @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  team      LobbyTeam?         @relation(fields: [teamId], references: [id])
  user      User?              @relation("UserLobbyPlayers", fields: [userId], references: [id])
  responses LobbyPlayerResponse[]

  // Indexes (KHÔNG unique vì field optional)
  @@index([sessionId])
  @@index([sessionId, userId])      // hỗ trợ lookup: 1 user chỉ 1 player / session (enforce ở service)
  @@index([sessionId, clientKey])   // hỗ trợ lookup: 1 clientKey chỉ 1 player / session (enforce ở service)

  @@map("lobby_players")
}

model LobbyPlayerResponse {
  id            String   @id @default(auto()) @map("_id") @db.ObjectId
  sessionId     String   @db.ObjectId
  playerId      String   @db.ObjectId
  questionId    String   @db.ObjectId
  answerId      String?  @db.ObjectId
  isCorrect     Boolean
  timeTakenMs   Int
  basePoints    Float
  speedBonus    Float
  pointsAwarded Float
  createdAt     DateTime @default(now())

  // Relations
  session       LobbySession   @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  player        LobbyPlayer    @relation(fields: [playerId], references: [id], onDelete: Cascade)
  question      KahootQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)
  answer        KahootAnswer?  @relation(fields: [answerId], references: [id])

  @@map("lobby_player_responses")
}

////////////////////////////////////////////////////////////
// CHALLENGE
////////////////////////////////////////////////////////////

enum ChallengeStatus { 
  draft
  open
  closed
}

model Challenge {
  id                  String   @id @default(auto()) @map("_id") @db.ObjectId
  kahootId            String   @db.ObjectId
  creatorId           String   @db.ObjectId
  pinCode             String?  @unique
  title               String
  introText           String?
  startAt             DateTime?
  dueAt               DateTime?
  status              ChallengeStatus @default(open)
  answerOrderRandom   Boolean @default(true)
  questionOrderRandom Boolean @default(false)
  streaksEnabled      Boolean @default(true)
  createdAt           DateTime @default(now())

  // Relations
  kahoot              Kahoot @relation(fields: [kahootId], references: [id], onDelete: Cascade)
  creator             User   @relation("UserChallenges", fields: [creatorId], references: [id], onDelete: Cascade)
  attempts            ChallengeAttempt[]

  @@index([kahootId])
  @@index([creatorId])
  @@index([status])
  @@index([startAt])
  @@index([dueAt])
  @@map("challenges")

}

model ChallengeAttempt {
  id              String   @id @default(auto()) @map("_id") @db.ObjectId
  challengeId     String   @db.ObjectId
  userId          String?  @db.ObjectId
  nickname        String
  startedAt       DateTime @default(now())
  submittedAt     DateTime?
  scoreTotal      Float    @default(0)
  streakMax       Int      @default(0)

  // Snapshot thứ tự để cố định random lúc start
  questionOrder    String[] @default([])        // ✅ mảng questionId theo thứ tự
  answerOrderMap   Json?                        // { [questionId]: string[] answerId }
  settingsSnapshot Json?                        // copy flag/tùy chọn chấm điểm tại thời điểm start

  // Relations
  challenge   Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  user        User?     @relation("UserChallengeAttempts", fields: [userId], references: [id])
  responses   ChallengeResponse[]

  @@index([challengeId, userId])
  @@index([challengeId, scoreTotal(sort: Desc)])  // leaderboard
  @@map("challenge_attempts")

}

model ChallengeResponse {
    id            String   @id @default(auto()) @map("_id") @db.ObjectId
  attemptId     String   @db.ObjectId
  questionId    String   @db.ObjectId
  answerId      String?  @db.ObjectId
  isCorrect     Boolean
  timeTakenMs   Int
  basePoints    Float
  speedBonus    Float
  pointsAwarded Float
  createdAt     DateTime @default(now())

  // Relations
  attempt       ChallengeAttempt @relation(fields: [attemptId], references: [id], onDelete: Cascade)
  question      KahootQuestion   @relation(fields: [questionId], references: [id], onDelete: Cascade)
  answer        KahootAnswer?    @relation(fields: [answerId], references: [id])

  @@unique([attemptId, questionId])           // <— một câu hỏi chỉ có 1 bản ghi/attempt
  @@index([attemptId])
  @@index([questionId])
  @@map("challenge_responses")

}

////////////////////////////////////////////////////////////
// REPORTS
////////////////////////////////////////////////////////////

enum ReportSource { 
  lobby_session 
  challenge
}

model GameReport {
  id              String   @id @default(auto()) @map("_id") @db.ObjectId
  source          ReportSource
  sourceId        String
  kahootId        String   @db.ObjectId
  hostId          String   @db.ObjectId
  totalPlayers    Int
  totalQuestions  Int
  avgAccuracy     Float
  createdAt       DateTime @default(now())

  // Relations
  kahoot          Kahoot @relation(fields: [kahootId], references: [id], onDelete: Cascade)
  host            User   @relation("UserGameReports", fields: [hostId], references: [id], onDelete: Cascade)
  reportPlayers   ReportPlayer[]

  @@map("game_reports")
}

model ReportPlayer {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  reportId     String   @db.ObjectId
  userId       String?  @db.ObjectId
  nickname     String
  rank         Int
  scoreTotal   Float
  streakMax    Int
  correctCount Int
  wrongCount   Int

  // Relations
  report       GameReport @relation(fields: [reportId], references: [id], onDelete: Cascade)
  user         User?      @relation("UserReportPlayers", fields: [userId], references: [id])

  @@index([reportId])
  @@map("report_players")
}

////////////////////////////////////////////////////////////
// SOCIAL & SYSTEM
////////////////////////////////////////////////////////////

model Favorite {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  userId     String   @db.ObjectId
  kahootId   String   @db.ObjectId
  createdAt  DateTime @default(now())

  // Relations
  user       User   @relation("UserFavorites", fields: [userId], references: [id], onDelete: Cascade)
  kahoot     Kahoot @relation(fields: [kahootId], references: [id], onDelete: Cascade)

  @@unique([userId, kahootId])
  @@map("favorites")
}

model Comment {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  kahootId   String   @db.ObjectId
  userId     String   @db.ObjectId
  content    String
  createdAt  DateTime @default(now())
  parentId   String?

  // Relations
  kahoot     Kahoot @relation(fields: [kahootId], references: [id], onDelete: Cascade)
  user       User   @relation("UserComments", fields: [userId], references: [id], onDelete: Cascade)

  @@map("comments")
}

model AuditLog {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  actorId     String   @db.ObjectId
  action      String
  targetType  String
  targetId    String
  diffJson    String?
  createdAt   DateTime @default(now())

  // Relations
  actor       User @relation("UserAuditLogs", fields: [actorId], references: [id], onDelete: Cascade)

  @@map("audit_logs")
}

model File {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  ownerId    String   @db.ObjectId
  url        String
  mime       String
  size       Int
  metaJson   String?
  createdAt  DateTime @default(now())

  // Relations
  owner      User @relation("UserFiles", fields: [ownerId], references: [id], onDelete: Cascade)

  @@map("files")
}
